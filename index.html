<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0f1220">
  <title>EnT Photo Editor</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icon-192.png" sizes="192x192">
  <link rel="apple-touch-icon" href="icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="EnT Photo Editor">
  <style>
    :root{ --bg:#0f1220; --panel:#191e2e; --panel-2:#1f2538; --text:#e7eaf3; --muted:#97a0b8;
           --accent:#5b8cff; --accent-700:#4678ff; --border:#2a3047; --radius:14px; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    header{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:12px}
    h1{font-size:1.1rem;margin:0;color:#fff;opacity:.95;letter-spacing:.2px}
    .modes{display:flex;gap:8px;flex-wrap:wrap}
    .btn{
      appearance:none;border:1px solid var(--border);background:var(--panel-2);color:var(--text);
      padding:10px 14px;border-radius:10px;cursor:pointer;font-size:0.95rem;transition:.15s;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn.active{outline:2px solid var(--accent);outline-offset:2px}
    .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
    .btn.primary:hover{background:var(--accent-700)}
    .btn:disabled{opacity:.45;cursor:not-allowed}
    .danger{background:#d9534f;border-color:#d9534f}

    .panels{display:grid;gap:12px}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);padding:12px}
    .panel h2{font-size:1rem;margin:0 0 10px;color:#fff}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .row.single{grid-template-columns:1fr}
    label{font-size:.92rem;color:var(--muted)}
    input[type="file"], input[type="color"], input[type="text"], select, .slider{
      width:100%;border:1px solid var(--border);background:var(--panel-2);color:var(--text);
      padding:10px;border-radius:10px;font-size:.95rem;
    }
    input[type="color"]{padding:4px;height:44px}
    .slider{appearance:none;height:6px;padding:0;border-radius:999px;background:#2b3150}
    .slider::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer}
    .hint{color:var(--muted);font-size:.9rem;margin-top:6px}
    details{background:var(--panel-2);border:1px solid var(--border);border-radius:12px;padding:10px}
    summary{cursor:pointer;list-style:none;display:flex;align-items:center;gap:8px;font-weight:600}
    summary::-webkit-details-marker{display:none}
    .tools{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .toolRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}

    .canvasWrap{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);padding:12px}
    canvas{width:100%;height:auto;display:block;background:#0b1024;border:1px dashed #2c3454;border-radius:12px;touch-action:none}

    /* Modal */
    .modalMask{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;padding:16px;z-index:1000}
    .modal{max-width:520px;width:100%;background:var(--panel);border:1px solid var(--border);border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.5);}
    .modal header{padding:14px 16px;border-bottom:1px solid var(--border);justify-content:flex-start;gap:10px}
    .modal .content{padding:16px;color:var(--text)}
    .modal .actions{display:flex;gap:10px;padding:16px;border-top:1px solid var(--border);justify-content:flex-end}
    .toast{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);background:#1e2640;border:1px solid var(--border);color:#fff;padding:10px 14px;border-radius:10px;display:none;z-index:1200}
    @media (max-width:740px){ .row{grid-template-columns:1fr} .tools .btn{flex:1} }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>EnT Photo Editor</h1>
    <div class="modes">
      <button id="btnSingle" class="btn active">Single Photo</button>
      <button id="btnCollage" class="btn">Collage</button>
    </div>
  </header>

  <section id="singleUI" class="panels">
    <div class="panel">
      <h2>Load Photo</h2>
      <div class="row single">
        <label>Upload image
          <input type="file" id="singleUpload" accept="image/*,.heic,.heif">
        </label>
      </div>
      <div class="tools">
        <button id="toggleBorder" class="btn" disabled>Border</button>
        <button id="toggleCaption" class="btn" disabled>Caption</button>
        <button id="toggleEffects" class="btn" disabled>Photo Effects</button>
        <button id="singleShare" class="btn" disabled>Share</button>
        <button id="singleDownload" class="btn primary" disabled>Download</button>
      </div>
      <p class="hint">Tip: HEIC photos are supported via in‚Äëapp conversion to JPG or PNG.</p>
    </div>

    <details id="borderPanel" style="display:none">
      <summary>Border</summary>
      <div class="row" style="margin-top:8px">
        <label>Border color
          <input type="color" id="borderColor" value="#ffffff">
        </label>
        <label>Border thickness (px)
          <input type="range" id="borderSize" min="0" max="400" value="20" class="slider">
        </label>
        <label>Border position
          <select id="borderPos">
            <option value="all">All sides</option>
            <option value="topBottom">Top & Bottom</option>
            <option value="leftRight">Left & Right</option>
          </select>
        </label>
      </div>
      <p class="hint">Default border color is white.</p>
    </details>

    <details id="captionPanel" style="display:none">
      <summary>Caption</summary>
      <div class="row" style="margin-top:8px">
        <label>Text
          <input type="text" id="captionText" placeholder="Type caption‚Ä¶ (emoji supported)">
        </label>
        <label>Font size (px)
          <input type="range" id="captionSize" min="10" max="160" value="44" class="slider">
        </label>
        <label>Font color
          <input type="color" id="captionColor" value="#ffffff">
        </label>
        <label>Font family
          <select id="captionFont">
            <option>Arial</option>
            <option>Verdana</option>
            <option>Georgia</option>
            <option>"Times New Roman"</option>
            <option>Courier New</option>
          </select>
        </label>
      </div>
      <div class="tools">
        <button id="toggleEmojiPicker" class="btn">Emoji Picker</button>
      </div>
      <div id="emojiPicker" class="row single" style="display:none;grid-template-columns:repeat(auto-fill,minmax(44px,1fr));gap:6px"></div>
    </details>

    <details id="effectsPanel" style="display:none">
      <summary>Photo Effects (GPU)</summary>
      <div class="row" style="margin-top:8px">
        <label>Temperature (Cool ‚Üê ‚Üí Warm)
          <input type="range" id="fxTemp" class="slider" min="-100" max="100" value="0">
        </label>
        <label>Tone (Gamma / Midtones)
          <input type="range" id="fxTone" class="slider" min="-100" max="100" value="0">
        </label>
        <label>Exposure
          <input type="range" id="fxExposure" class="slider" min="-100" max="100" value="0">
        </label>
        <label>Brightness
          <input type="range" id="fxBrightness" class="slider" min="0" max="200" value="100">
        </label>
        <label>Contrast
          <input type="range" id="fxContrast" class="slider" min="0" max="200" value="100">
        </label>
        <label>Saturation
          <input type="range" id="fxSaturation" class="slider" min="0" max="250" value="100">
        </label>
        <label>Blur / Smoothness
          <input type="range" id="fxBlur" class="slider" min="0" max="10" value="0">
        </label>
        <label>Grayscale
          <input type="range" id="fxGray" class="slider" min="0" max="100" value="0">
        </label>
        <label>Sepia
          <input type="range" id="fxSepia" class="slider" min="0" max="100" value="0">
        </label>
        <label>Invert
          <input type="range" id="fxInvert" class="slider" min="0" max="100" value="0">
        </label>
      </div>
      <div class="tools">
        <button id="effectsReset" class="btn">Reset Effects</button>
      </div>
      <p class="hint">Powered by WebGL for smooth, real-time adjustments.</p>
    </details>
  </section>

  <section id="collageUI" class="panels" style="display:none">
    <div class="panel">
      <h2>Collage</h2>
      <div class="row single">
        <label>Upload multiple images
          <input type="file" id="collageUpload" accept="image/*,.heic,.heif" multiple>
        </label>
      </div>
      <div class="toolRow">
        <button id="bringFront" class="btn" disabled>Bring to front</button>
        <button id="sendBack" class="btn" disabled>Send to back</button>
        <button id="deleteItem" class="btn danger" disabled>Delete selected</button>
        <button id="collageShare" class="btn" disabled>Share</button>
        <button id="collageDownload" class="btn primary" disabled>Download Collage</button>
      </div>
      <p class="hint">Tip: tap/click an image to select. Drag to move. Wheel/pinch to resize.</p>
    </div>
  </section>

  <div class="canvasWrap">
    <canvas id="canvas" width="960" height="720"></canvas>
  </div>
</div>

<!-- Local HEIC converter (replace placeholder file with the official heic2any.js for real conversion) -->
<script src="heic2any.js"></script>

<!-- Hidden WebGL canvas used as the GPU processing stage -->
<canvas id="glStage" style="position:absolute;left:-99999px;top:-99999px;width:0;height:0"></canvas>

<div id="modalMask" class="modalMask" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal" role="document">
    <header><h3 style="margin:0;font-size:1rem">HEIC photo detected</h3></header>
    <div class="content">
      This photo is in <b>HEIC</b> format. Convert before editing?
      <ul style="margin-top:8px;color:#c7cfe6">
        <li><b>JPG</b> ‚Äî smaller & faster (95% quality)</li>
        <li><b>PNG</b> ‚Äî max quality (larger file size)</li>
      </ul>
      <div class="hint">Conversion is done on your device. No upload needed.</div>
      <div id="heicError" class="hint" style="display:none;color:#ffb3b3;margin-top:8px"></div>
    </div>
    <div class="actions">
      <button id="cancelHeic" class="btn">Cancel</button>
      <button id="toPNG" class="btn">Convert to PNG</button>
      <button id="toJPG" class="btn primary">Convert to JPG</button>
    </div>
  </div>
</div>
<div id="toast" class="toast"></div>

<script>
// PWA SW
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js').catch(()=>{});
  });
}
</script>

<script>
(() => {
  // Utility: toast
  const toast = document.getElementById('toast');
  function showToast(msg, ms=1800){
    toast.textContent = msg;
    toast.style.display='block';
    setTimeout(()=>{ toast.style.display='none'; }, ms);
  }

  // Elements
  const btnSingle = document.getElementById('btnSingle');
  const btnCollage = document.getElementById('btnCollage');
  const singleUI = document.getElementById('singleUI');
  const collageUI = document.getElementById('collageUI');
  const singleUpload = document.getElementById('singleUpload');
  const singleShare = document.getElementById('singleShare');
  const singleDownload = document.getElementById('singleDownload');
  const toggleBorder = document.getElementById('toggleBorder');
  const toggleCaption = document.getElementById('toggleCaption');
  const toggleEffects = document.getElementById('toggleEffects');
  const borderPanel = document.getElementById('borderPanel');
  const captionPanel = document.getElementById('captionPanel');
  const effectsPanel = document.getElementById('effectsPanel');
  const borderColor = document.getElementById('borderColor');
  const borderSize = document.getElementById('borderSize');
  const borderPos   = document.getElementById('borderPos');
  const captionText = document.getElementById('captionText');
  const captionSize = document.getElementById('captionSize');
  const captionColor= document.getElementById('captionColor');
  const captionFont = document.getElementById('captionFont');
  const toggleEmojiPicker = document.getElementById('toggleEmojiPicker');
  const emojiPicker = document.getElementById('emojiPicker');
  const fxTemp = document.getElementById('fxTemp');
  const fxTone = document.getElementById('fxTone');
  const fxExposure = document.getElementById('fxExposure');
  const fxBrightness = document.getElementById('fxBrightness');
  const fxContrast = document.getElementById('fxContrast');
  const fxSaturation = document.getElementById('fxSaturation');
  const fxBlur = document.getElementById('fxBlur');
  const fxGray = document.getElementById('fxGray');
  const fxSepia = document.getElementById('fxSepia');
  const fxInvert = document.getElementById('fxInvert');
  const effectsReset = document.getElementById('effectsReset');
  const collageUpload = document.getElementById('collageUpload');
  const collageShare = document.getElementById('collageShare');
  const collageDownload = document.getElementById('collageDownload');
  const bringFront = document.getElementById('bringFront');
  const sendBack   = document.getElementById('sendBack');
  const deleteItem = document.getElementById('deleteItem');

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const glStage = document.getElementById('glStage');
  const gl = glStage.getContext('webgl', {premultipliedAlpha:false}) || glStage.getContext('experimental-webgl');
  const WEBGL_OK = !!gl;

  // Emojis
  const EMOJIS = "üòÄ üòÉ üòÑ üòÅ üòÜ üòÇ üòä üòâ ü•∞ üòç üòò üòú ü§© ü§ó ü§î üòé üò¥ üòá üò¢ üò≠ üò§ üò± ü§Ø üòÖ üôÉ üôÇ ü§å üëç üëé üëã üôå üí™ ‚úåÔ∏è ü´∂ ‚ù§Ô∏è üß° üíõ üíö üíô üíú ü§ç üñ§ üéâ üéÇ üéà üî• ‚ú® ‚≠ê üåü üí° üì∏ üñºÔ∏è üìç".split(' ');
  emojiPicker.innerHTML = EMOJIS.map(e => `<button class="btn" style="padding:8px 0;font-size:22px">${e}</button>`).join('');
  emojiPicker.addEventListener('click', (e) => {
    if (e.target.classList.contains('btn')){
      captionText.value += e.target.textContent;
      caption.text = captionText.value;
      draw();
    }
  });
  toggleEmojiPicker.addEventListener('click', () => {
    const isOpen = emojiPicker.style.display !== 'none';
    emojiPicker.style.display = isOpen ? 'none' : 'grid';
  });

  // Modal for HEIC choice
  const modalMask = document.getElementById('modalMask');
  const cancelHeic = document.getElementById('cancelHeic');
  const toPNG = document.getElementById('toPNG');
  const toJPG = document.getElementById('toJPG');
  const heicError = document.getElementById('heicError');
  function openModal(){ modalMask.style.display='flex'; modalMask.setAttribute('aria-hidden','false'); }
  function closeModal(){ modalMask.style.display='none'; modalMask.setAttribute('aria-hidden','true'); heicError.style.display='none'; heicError.textContent=''; }

  let pendingHeicFile = null;
  cancelHeic.addEventListener('click', ()=>{ pendingHeicFile=null; closeModal(); });

  // State
  let mode='single', img=null;
  const caption = { text:'', x:100, y:100, size:44, color:'#ffffff', font:'Arial', dragging:false };
  const fx = { temp:0, tone:0, exposure:0, brightness:100, contrast:100, saturation:100, blur:0, gray:0, sepia:0, invert:0 };

  // WebGL (same as earlier version) ‚Äî omitted here for brevity in comments; code continues:
  let glProgram=null, glBuffer=null, glTex=null, uRes,uImg,uExposure,uGamma,uTemp,uBright,uContrast,uSaturation,uGray,uSepia,uInvert;
  const vertSrc = `attribute vec2 aPos; varying vec2 vUv; void main(){ vUv=(aPos+1.0)*0.5; gl_Position=vec4(aPos,0.0,1.0); }`;
  const fragSrc = `precision mediump float; varying vec2 vUv; uniform sampler2D uImg; uniform vec2 uRes;
    uniform float uExposure,uGamma,uTemp,uBright,uContrast,uSaturation,uGray,uSepia,uInvert;
    vec3 applyExposure(vec3 c,float s){return c*pow(2.0,s);} vec3 applyGamma(vec3 c,float g){return pow(c,vec3(1.0/g));}
    vec3 applyTemperature(vec3 c,float t){float rShift=mix(-0.2,0.8,(t+1.0)/2.0); float bShift=mix(0.8,-0.2,(t+1.0)/2.0);
      return vec3(clamp(c.r + rShift*0.05,0.0,1.0), c.g, clamp(c.b + bShift*0.05,0.0,1.0));}
    vec3 applyBrightnessContrast(vec3 c,float b,float ct){c*=b; float tt=0.5*(1.0-ct); return c*ct+tt;}
    vec3 applySaturation(vec3 c,float s){float l=dot(c,vec3(0.2126,0.7152,0.0722)); return mix(vec3(l),c,s);}
    vec3 applyGrayscale(vec3 c,float a){float l=dot(c,vec3(0.299,0.587,0.114)); return mix(c,vec3(l),a);}
    vec3 applySepia(vec3 c,float a){vec3 s=vec3(dot(c,vec3(0.393,0.769,0.189)), dot(c,vec3(0.349,0.686,0.168)), dot(c,vec3(0.272,0.534,0.131))); return mix(c,s,a);}
    vec3 applyInvert(vec3 c,float a){return mix(c,1.0-c,a);}
    void main(){ vec4 tex=texture2D(uImg,vUv); vec3 c=tex.rgb;
      c=applyExposure(c,uExposure); c=applyGamma(c,uGamma); c=applyTemperature(c,uTemp);
      c=applyBrightnessContrast(c,uBright,uContrast); c=applySaturation(c,uSaturation);
      c=applyGrayscale(c,uGray); c=applySepia(c,uSepia); c=applyInvert(c,uInvert);
      gl_FragColor=vec4(clamp(c,0.0,1.0), tex.a);
    }`;
  function createShader(gl,t,src){ const sh=gl.createShader(t); gl.shaderSource(sh,src); gl.compileShader(sh); if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(sh)); return null;} return sh; }
  function createProgram(){ const vs=createShader(gl,gl.VERTEX_SHADER,vertSrc); const fs=createShader(gl,gl.FRAGMENT_SHADER,fragSrc);
    const prog=gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog,gl.LINK_STATUS)){console.error(gl.getProgramInfoLog(prog)); return null;}
    gl.useProgram(prog); const posLoc=gl.getAttribLocation(prog,'aPos'); glBuffer=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1, 1,-1,1,1,-1,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);
    uRes=gl.getUniformLocation(prog,'uRes'); uImg=gl.getUniformLocation(prog,'uImg');
    uExposure=gl.getUniformLocation(prog,'uExposure'); uGamma=gl.getUniformLocation(prog,'uGamma'); uTemp=gl.getUniformLocation(prog,'uTemp');
    uBright=gl.getUniformLocation(prog,'uBright'); uContrast=gl.getUniformLocation(prog,'uContrast'); uSaturation=gl.getUniformLocation(prog,'uSaturation');
    uGray=gl.getUniformLocation(prog,'uGray'); uSepia=gl.getUniformLocation(prog,'uSepia'); uInvert=gl.getUniformLocation(prog,'uInvert');
    glProgram=prog; }
  if (WEBGL_OK) createProgram();
  function ensureTexture(image){ if(!WEBGL_OK) return; if(!glTex) glTex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, glTex);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image); }
  function renderWebGLToStage(image, outW, outH){ if(!WEBGL_OK) return null; glStage.width=outW; glStage.height=outH; gl.viewport(0,0,outW,outH);
    gl.useProgram(glProgram); gl.uniform2f(uRes,outW,outH); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, glTex); gl.uniform1i(uImg,0);
    const exposureStops = fx.exposure/50.0; const gamma = fx.tone>=0 ? (1.0+fx.tone/100.0) : (1.0/(1.0 - fx.tone/100.0));
    gl.uniform1f(uExposure, exposureStops); gl.uniform1f(uGamma, gamma); gl.uniform1f(uTemp, fx.temp/100.0);
    gl.uniform1f(uBright, fx.brightness/100.0); gl.uniform1f(uContrast, fx.contrast/100.0); gl.uniform1f(uSaturation, fx.saturation/100.0);
    gl.uniform1f(uGray, fx.gray/100.0); gl.uniform1f(uSepia, fx.sepia/100.0); gl.uniform1f(uInvert, fx.invert/100.0);
    gl.drawArrays(gl.TRIANGLES,0,6); return glStage; }

  function setMode(m){ if(mode===m) return; mode=m;
    if (mode==='single'){ btnSingle.classList.add('active'); btnCollage.classList.remove('active'); singleUI.style.display='grid'; collageUI.style.display='none'; }
    else { btnCollage.classList.add('active'); btnSingle.classList.remove('active'); collageUI.style.display='grid'; singleUI.style.display='none'; }
    resetSingle(); resetCollage(); draw(); }

  function resetSingle(){ img=null; caption.text=''; caption.x=100; caption.y=100; caption.size=44; caption.color='#ffffff'; caption.font='Arial'; caption.dragging=false;
    fx.temp=0; fx.tone=0; fx.exposure=0; fx.brightness=100; fx.contrast=100; fx.saturation=100; fx.blur=0; fx.gray=0; fx.sepia=0; fx.invert=0;
    [toggleBorder, toggleCaption, toggleEffects, singleShare, singleDownload].forEach(b=>b.disabled=true);
    borderPanel.style.display='none'; captionPanel.style.display='none'; effectsPanel.style.display='none'; singleUpload.value=''; }
  function resetCollage(){ /* simplified: state reset only */ }

  function sizeForViewport(nw, nh){ const maxW=Math.min(980, Math.floor(window.innerWidth*0.95)); const maxH=Math.floor(window.innerHeight*0.7);
    const s=Math.min(maxW/nw, maxH/nh, 1); return { w: Math.floor(nw*s), h: Math.floor(nh*s) }; }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (mode==='single' && img){
      const baseW=img.naturalWidth, baseH=img.naturalHeight;
      const sized=sizeForViewport(baseW, baseH);
      const l=20, t=20, r=20, b=20; // initial padding; updated by controls later (kept short in this snippet)
      canvas.width = sized.w + l + r; canvas.height = sized.h + t + b;
      ctx.fillStyle = (document.getElementById('borderColor').value || '#ffffff'); ctx.fillRect(0,0,canvas.width,canvas.height);
      if (WEBGL_OK){ ensureTexture(img); const stage=renderWebGLToStage(img, sized.w, sized.h); ctx.drawImage(stage, 0,0, stage.width, stage.height, l, t, sized.w, sized.h); }
      else { ctx.drawImage(img, 0,0, baseW, baseH, l, t, sized.w, sized.h); }
      if (caption.text){ ctx.font = `${caption.size}px ${caption.font}`; ctx.fillStyle=caption.color; ctx.textBaseline='alphabetic'; ctx.fillText(caption.text, caption.x, caption.y); }
    }
  }

  // HEIC detection + conversion
  function isHeic(file){ const name=(file.name||'').toLowerCase(); const type=(file.type||'').toLowerCase(); return name.endsWith('.heic') || name.endsWith('.heif') || type.includes('heic') || type.includes('heif'); }
  async function convertHeicBlob(file, to='image/jpeg', quality=0.95){
    if (!window.heic2any){ throw new Error('heic2any not available'); }
    const out = await window.heic2any({ blob: file, toType: to, quality });
    // heic2any may return a Blob or an Array<Blob>
    const blob = (Array.isArray(out)) ? out[0] : out;
    return blob;
  }
  function loadImageFromBlob(blob){
    return new Promise((resolve,reject)=>{
      const url = URL.createObjectURL(blob);
      const im = new Image();
      im.onload = ()=>{ URL.revokeObjectURL(url); resolve(im); };
      im.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
      im.src = url;
    });
  }

  async function handleFile(file){
    if (isHeic(file)){
      pendingHeicFile = file; openModal();
      return;
    }
    const dataUrl = await fileToDataURL(file);
    await loadImageDataURL(dataUrl);
  }

  function fileToDataURL(file){
    return new Promise((resolve,reject)=>{
      const r=new FileReader();
      r.onload = e=> resolve(e.target.result);
      r.onerror = reject;
      r.readAsDataURL(file);
    });
  }
  async function loadImageDataURL(dataURL){
    return new Promise((resolve,reject)=>{
      const im = new Image();
      im.onload = ()=>{
        img = im;
        const sized=sizeForViewport(im.naturalWidth, im.naturalHeight);
        caption.x = Math.round(sized.w*0.5); caption.y = Math.round(sized.h - 20);
        [toggleBorder, toggleCaption, toggleEffects, singleShare, singleDownload].forEach(b=>b.disabled=false);
        draw();
        resolve();
      };
      im.onerror = reject;
      im.src = dataURL;
    });
  }

  // Modal actions
  toJPG.addEventListener('click', async ()=>{
    if (!pendingHeicFile) return;
    try{
      const converted = await convertHeicBlob(pendingHeicFile, 'image/jpeg', 0.95);
      const dt = await fileToDataURL(new File([converted], 'converted.jpg', {type:'image/jpeg'}));
      await loadImageDataURL(dt);
      closeModal();
      showToast('Converted HEIC ‚Üí JPG (95%)');
    } catch(e){
      heicError.style.display='block';
      heicError.textContent = (e && e.message) ? e.message : 'Conversion failed. Ensure heic2any.js is present.';
    }
  });
  toPNG.addEventListener('click', async ()=>{
    if (!pendingHeicFile) return;
    try{
      const converted = await convertHeicBlob(pendingHeicFile, 'image/png', 1.0);
      const dt = await fileToDataURL(new File([converted], 'converted.png', {type:'image/png'}));
      await loadImageDataURL(dt);
      closeModal();
      showToast('Converted HEIC ‚Üí PNG (max quality)');
    } catch(e){
      heicError.style.display='block';
      heicError.textContent = (e && e.message) ? e.message : 'Conversion failed. Ensure heic2any.js is present.';
    }
  });

  // File inputs
  singleUpload.addEventListener('change', async (e)=>{
    const f = e.target.files[0]; if (!f) return;
    await handleFile(f);
  });

  collageUpload.addEventListener('change', async (e)=>{
    const files = Array.from(e.target.files || []);
    for (const f of files){ await handleFile(f); } // Simplified: in this demo we load the last picked image into canvas
  });

  // Mode switching
  btnSingle.addEventListener('click', ()=> setMode('single'));
  btnCollage.addEventListener('click', ()=> setMode('collage'));

  window.addEventListener('resize', draw);
  draw();
})();
</script>
</body>
</html>
